<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes By Example</title>
    <link>http://kubernetesbyexample.com/</link>
    <description>Recent content on Kubernetes By Example</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 26 Apr 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://kubernetesbyexample.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Environment Variables</title>
      <link>http://kubernetesbyexample.com/envs/</link>
      <pubDate>Wed, 26 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://kubernetesbyexample.com/envs/</guid>
      <description>You can set environment variables for containers running in a pod and in addition, Kubernetes exposes certain runtime infos via environment variables automatically.
Let&amp;rsquo;s launch a pod that we pass an environment variable SIMPLE_SERVICE_VERSION with the value 1.0:
$ kubectl create -f https://raw.githubusercontent.com/mhausenblas/kbe/master/specs/envs/pod.yaml $ kubectl describe pod envs | grep IP: IP: 172.17.0.3  Now, let&amp;rsquo;s verify from within the cluster if the application running in the pod has picked up the environment variable SIMPLE_SERVICE_VERSION:</description>
    </item>
    
    <item>
      <title>Namespaces</title>
      <link>http://kubernetesbyexample.com/ns/</link>
      <pubDate>Wed, 26 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://kubernetesbyexample.com/ns/</guid>
      <description>Namespaces provide for a scope of Kubernetes objects. You can think of it as a workspace you&amp;rsquo;re sharing with other users. Many objects such as pods and services are namespaced, while some (like nodes) are not. As a developer you&amp;rsquo;d usually simply use an assigned namespace, however admins may wish to manage them, for example to set up access control or resource quotas.
Let&amp;rsquo;s list all namespaces (note that the output will depend on the environment you&amp;rsquo;re using, I&amp;rsquo;m using Minishift):</description>
    </item>
    
    <item>
      <title>Secrets</title>
      <link>http://kubernetesbyexample.com/secrets/</link>
      <pubDate>Wed, 26 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://kubernetesbyexample.com/secrets/</guid>
      <description>You don&amp;rsquo;t want sensitive information such as a database password or an API key keep around in clear text. Secrets provide you with a mechanism to use such information in a safe and reliable way.
Let&amp;rsquo;s create a secret apikey that holds a (made-up) API key:
$ echo -n &amp;quot;A19fh68B001j&amp;quot; &amp;gt; ./apikey.txt $ kubectl create secret generic apikey --from-file=./apikey.txt secret &amp;quot;apikey&amp;quot; created $ kubectl describe secrets/apikey Name: apikey Namespace: default Labels: &amp;lt;none&amp;gt; Annotations: &amp;lt;none&amp;gt; Type: Opaque Data ==== apikey.</description>
    </item>
    
    <item>
      <title>Health Checks</title>
      <link>http://kubernetesbyexample.com/healthz/</link>
      <pubDate>Tue, 25 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://kubernetesbyexample.com/healthz/</guid>
      <description>In order to verify if a container in a pod is in a state to serve traffic, Kubernetes provides for a range of health checking mechanisms. We will focus on HTTP health checks in the following. It is the responsibility of the application developer to expose an endpoint that Kubernetes can use to determine if the container is healthy.
Let&amp;rsquo;s create a pod that exposes an endpoint health/, responding with a HTTP 200 status code:</description>
    </item>
    
    <item>
      <title>Labels</title>
      <link>http://kubernetesbyexample.com/labels/</link>
      <pubDate>Tue, 25 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://kubernetesbyexample.com/labels/</guid>
      <description>Labels are the mechanism you use to organize Kubernetes objects. A label is a key-value pair with certain restrictions concerning length and allowed values but without any pre-defined meaning. So you&amp;rsquo;re free to choose labels as you see fit, for example, to express environments such as &amp;lsquo;this pod is running in production&amp;rsquo; or ownership, like &amp;lsquo;department X owns that pod&amp;rsquo;.
Let&amp;rsquo;s create a pod that initially has one label (env=development):</description>
    </item>
    
    <item>
      <title>Replication Controllers</title>
      <link>http://kubernetesbyexample.com/rcs/</link>
      <pubDate>Tue, 25 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://kubernetesbyexample.com/rcs/</guid>
      <description>A replication controller (RC) is a supervisor for long-running pods. An RC will launch a specified number of pods called replicas and makes sure that they keep running, for example when a node fails or something inside of a pod, that is, in one of its containers goes wrong.
Let&amp;rsquo;s create an RC that supervises a single replica of a pod:
$ kubectl create -f https://raw.githubusercontent.com/mhausenblas/kbe/master/specs/rcs/rc.yaml  You can see the RC and the pod it looks after like so:</description>
    </item>
    
    <item>
      <title>Services</title>
      <link>http://kubernetesbyexample.com/services/</link>
      <pubDate>Tue, 25 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://kubernetesbyexample.com/services/</guid>
      <description>A service is an abstraction for pods, providing a stable, virtual IP (VIP) address. While pods may come and go, services allow clients to reliably connect to the containers running in the pods, using the VIP. The virtual in VIP means itâ€™s not an actual IP address connected to a network interface but its purpose is purely to forward traffic to one or more pods. Keeping the mapping between the VIP and the pods up-to-date is the job of kube-proxy, a process that runs on every node, which queries the API server to learn about new services in the cluster.</description>
    </item>
    
    <item>
      <title>DIY</title>
      <link>http://kubernetesbyexample.com/diy/</link>
      <pubDate>Mon, 24 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://kubernetesbyexample.com/diy/</guid>
      <description>If you want to try out the examples here yourself, you can use the same setup I&amp;rsquo;ve got locally running on my machine:
 Install Minishift Run minishift start Install oc Log in using oc login -u system:admin with password admin Create a symlink like so: ln -s oc kubectl  </description>
    </item>
    
    <item>
      <title>Pods</title>
      <link>http://kubernetesbyexample.com/pods/</link>
      <pubDate>Mon, 24 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://kubernetesbyexample.com/pods/</guid>
      <description>The basic unit of deployment in Kubernetes is a pod. A pod is a collection of containers sharing a network and mount namespace with the guarantee that all of the containers are scheduled on the same node.
To launch a pod using a Docker image that exposes a HTTP API at port 9876, execute:
$ kubectl run sise --image=mhausenblas/simpleservice:0.5.0 --port=9876  We can now see that the pod is running:</description>
    </item>
    
  </channel>
</rss>